import * as assert from 'node:assert';
import { suite, test } from 'mocha';
import {
	createVulnerabilityAnalyzer,
	type VulnerabilityAnalyzerDeps,
} from '../../analyzers/vulnerabilityAnalyzer';
import { FINDING_TAGS } from '../../types';
import type { AnalysisContext } from '../../analyzers/types';
import { success, failure } from '../../shared/result';

suite('VulnerabilityAnalyzer Test Suite', () => {
	const createContext = (workspacePath = '/test'): AnalysisContext => ({
		packageJson: {},
		allDependencies: {},
		dependencyRanges: {},
		workspacePath,
	});

	suite('Vulnerability Detection', () => {
		test('should detect critical vulnerabilities', async () => {
			const mockDeps: VulnerabilityAnalyzerDeps = {
				runAudit: async () =>
					success({
						stdout: JSON.stringify({
							vulnerabilities: {
								lodash: {
									severity: 'critical',
									title: 'Prototype Pollution',
									module_name: 'lodash',
								},
							},
						}),
						stderr: '',
					}),
			};

			const analyzer = createVulnerabilityAnalyzer(mockDeps);
			const context = createContext();

			const result = await analyzer.analyze(context);

			assert.strictEqual(result.success, true);
			if (result.success) {
				const findings = result.data;
				assert.strictEqual(findings.length, 1);
				assert.strictEqual(findings[0].type, 'error');
				assert.ok(findings[0].message.includes('Prototype Pollution'));
				assert.ok(findings[0].message.includes('critical'));
				assert.strictEqual(findings[0].dependency, 'lodash');
				assert.ok(findings[0].tags?.includes(FINDING_TAGS.SECURITY));
			}
		});

		test('should detect high severity vulnerabilities as errors', async () => {
			const mockDeps: VulnerabilityAnalyzerDeps = {
				runAudit: async () =>
					success({
						stdout: JSON.stringify({
							vulnerabilities: {
								axios: {
									severity: 'high',
									title: 'Server-Side Request Forgery',
									module_name: 'axios',
								},
							},
						}),
						stderr: '',
					}),
			};

			const analyzer = createVulnerabilityAnalyzer(mockDeps);
			const context = createContext();

			const result = await analyzer.analyze(context);

			assert.strictEqual(result.success, true);
			if (result.success) {
				const findings = result.data;
				assert.strictEqual(findings[0].type, 'error');
				assert.ok(findings[0].message.includes('high'));
			}
		});

		test('should detect moderate vulnerabilities as warnings', async () => {
			const mockDeps: VulnerabilityAnalyzerDeps = {
				runAudit: async () =>
					success({
						stdout: JSON.stringify({
							vulnerabilities: {
								express: {
									severity: 'moderate',
									title: 'Open Redirect',
									module_name: 'express',
								},
							},
						}),
						stderr: '',
					}),
			};

			const analyzer = createVulnerabilityAnalyzer(mockDeps);
			const context = createContext();

			const result = await analyzer.analyze(context);

			assert.strictEqual(result.success, true);
			if (result.success) {
				const findings = result.data;
				assert.strictEqual(findings[0].type, 'warning');
				assert.ok(findings[0].message.includes('moderate'));
			}
		});

		test('should detect low severity vulnerabilities as warnings', async () => {
			const mockDeps: VulnerabilityAnalyzerDeps = {
				runAudit: async () =>
					success({
						stdout: JSON.stringify({
							vulnerabilities: {
								'debug-pkg': {
									severity: 'low',
									title: 'Information Disclosure',
									module_name: 'debug-pkg',
								},
							},
						}),
						stderr: '',
					}),
			};

			const analyzer = createVulnerabilityAnalyzer(mockDeps);
			const context = createContext();

			const result = await analyzer.analyze(context);

			assert.strictEqual(result.success, true);
			if (result.success) {
				const findings = result.data;
				assert.strictEqual(findings[0].type, 'warning');
			}
		});
	});

	suite('Multiple Vulnerabilities', () => {
		test('should detect multiple vulnerabilities', async () => {
			const mockDeps: VulnerabilityAnalyzerDeps = {
				runAudit: async () =>
					success({
						stdout: JSON.stringify({
							vulnerabilities: {
								lodash: {
									severity: 'critical',
									title: 'Prototype Pollution',
									module_name: 'lodash',
								},
								axios: {
									severity: 'high',
									title: 'SSRF',
									module_name: 'axios',
								},
								express: {
									severity: 'moderate',
									title: 'Open Redirect',
									module_name: 'express',
								},
							},
						}),
						stderr: '',
					}),
			};

			const analyzer = createVulnerabilityAnalyzer(mockDeps);
			const context = createContext();

			const result = await analyzer.analyze(context);

			assert.strictEqual(result.success, true);
			if (result.success) {
				const findings = result.data;
				assert.strictEqual(findings.length, 3);
			}
		});
	});

	suite('Legacy Advisories Format', () => {
		test('should parse legacy advisories format', async () => {
			const mockDeps: VulnerabilityAnalyzerDeps = {
				runAudit: async () =>
					success({
						stdout: JSON.stringify({
							advisories: {
								'1234': {
									severity: 'high',
									title: 'XSS Vulnerability',
									module_name: 'react',
								},
							},
						}),
						stderr: '',
					}),
			};

			const analyzer = createVulnerabilityAnalyzer(mockDeps);
			const context = createContext();

			const result = await analyzer.analyze(context);

			assert.strictEqual(result.success, true);
			if (result.success) {
				const findings = result.data;
				assert.strictEqual(findings.length, 1);
				assert.ok(findings[0].message.includes('XSS Vulnerability'));
			}
		});
	});

	suite('Package Name Variations', () => {
		test('should handle module_name field', async () => {
			const mockDeps: VulnerabilityAnalyzerDeps = {
				runAudit: async () =>
					success({
						stdout: JSON.stringify({
							vulnerabilities: {
								test: {
									severity: 'high',
									title: 'Test Vuln',
									module_name: 'test-package',
								},
							},
						}),
						stderr: '',
					}),
			};

			const analyzer = createVulnerabilityAnalyzer(mockDeps);
			const context = createContext();

			const result = await analyzer.analyze(context);

			assert.strictEqual(result.success, true);
			if (result.success) {
				assert.strictEqual(result.data[0].dependency, 'test-package');
			}
		});

		test('should fallback to name field', async () => {
			const mockDeps: VulnerabilityAnalyzerDeps = {
				runAudit: async () =>
					success({
						stdout: JSON.stringify({
							vulnerabilities: {
								test: {
									severity: 'high',
									title: 'Test Vuln',
									name: 'test-package-2',
								},
							},
						}),
						stderr: '',
					}),
			};

			const analyzer = createVulnerabilityAnalyzer(mockDeps);
			const context = createContext();

			const result = await analyzer.analyze(context);

			assert.strictEqual(result.success, true);
			if (result.success) {
				assert.strictEqual(result.data[0].dependency, 'test-package-2');
			}
		});

		test('should fallback to package_name field', async () => {
			const mockDeps: VulnerabilityAnalyzerDeps = {
				runAudit: async () =>
					success({
						stdout: JSON.stringify({
							vulnerabilities: {
								test: {
									severity: 'high',
									title: 'Test Vuln',
									package_name: 'test-package-3',
								},
							},
						}),
						stderr: '',
					}),
			};

			const analyzer = createVulnerabilityAnalyzer(mockDeps);
			const context = createContext();

			const result = await analyzer.analyze(context);

			assert.strictEqual(result.success, true);
			if (result.success) {
				assert.strictEqual(result.data[0].dependency, 'test-package-3');
			}
		});

		test('should fallback to findings array', async () => {
			const mockDeps: VulnerabilityAnalyzerDeps = {
				runAudit: async () =>
					success({
						stdout: JSON.stringify({
							vulnerabilities: {
								test: {
									severity: 'high',
									title: 'Test Vuln',
									findings: [{ package: 'test-package-4' }],
								},
							},
						}),
						stderr: '',
					}),
			};

			const analyzer = createVulnerabilityAnalyzer(mockDeps);
			const context = createContext();

			const result = await analyzer.analyze(context);

			assert.strictEqual(result.success, true);
			if (result.success) {
				assert.strictEqual(result.data[0].dependency, 'test-package-4');
			}
		});
	});

	suite('Severity Fallbacks', () => {
		test('should use metadata severity if main severity missing', async () => {
			const mockDeps: VulnerabilityAnalyzerDeps = {
				runAudit: async () =>
					success({
						stdout: JSON.stringify({
							vulnerabilities: {
								test: {
									title: 'Test Vuln',
									module_name: 'test-pkg',
									metadata: { severity: 'critical' },
								},
							},
						}),
						stderr: '',
					}),
			};

			const analyzer = createVulnerabilityAnalyzer(mockDeps);
			const context = createContext();

			const result = await analyzer.analyze(context);

			assert.strictEqual(result.success, true);
			if (result.success) {
				assert.strictEqual(result.data[0].type, 'error');
				assert.ok(result.data[0].message.includes('critical'));
			}
		});

		test('should default to moderate if no severity provided', async () => {
			const mockDeps: VulnerabilityAnalyzerDeps = {
				runAudit: async () =>
					success({
						stdout: JSON.stringify({
							vulnerabilities: {
								test: {
									title: 'Test Vuln',
									module_name: 'test-pkg',
								},
							},
						}),
						stderr: '',
					}),
			};

			const analyzer = createVulnerabilityAnalyzer(mockDeps);
			const context = createContext();

			const result = await analyzer.analyze(context);

			assert.strictEqual(result.success, true);
			if (result.success) {
				assert.strictEqual(result.data[0].type, 'warning');
				assert.ok(result.data[0].message.includes('moderate'));
			}
		});

		test('should use default title if missing', async () => {
			const mockDeps: VulnerabilityAnalyzerDeps = {
				runAudit: async () =>
					success({
						stdout: JSON.stringify({
							vulnerabilities: {
								test: {
									severity: 'high',
									module_name: 'test-pkg',
								},
							},
						}),
						stderr: '',
					}),
			};

			const analyzer = createVulnerabilityAnalyzer(mockDeps);
			const context = createContext();

			const result = await analyzer.analyze(context);

			assert.strictEqual(result.success, true);
			if (result.success) {
				assert.ok(result.data[0].message.includes('Vulnerability detected'));
			}
		});
	});

	suite('Error Handling', () => {
		test('should handle audit command failure', async () => {
			const mockDeps: VulnerabilityAnalyzerDeps = {
				runAudit: async () => failure('npm command not found'),
			};

			const analyzer = createVulnerabilityAnalyzer(mockDeps);
			const context = createContext();

			const result = await analyzer.analyze(context);

			assert.strictEqual(result.success, true);
			if (result.success) {
				assert.strictEqual(result.data.length, 0);
			}
		});

		test('should handle invalid JSON', async () => {
			const mockDeps: VulnerabilityAnalyzerDeps = {
				runAudit: async () =>
					success({
						stdout: 'not valid json',
						stderr: '',
					}),
			};

			const analyzer = createVulnerabilityAnalyzer(mockDeps);
			const context = createContext();

			const result = await analyzer.analyze(context);

			assert.strictEqual(result.success, true);
			if (result.success) {
				assert.strictEqual(result.data.length, 0);
			}
		});

		test('should handle empty stdout', async () => {
			const mockDeps: VulnerabilityAnalyzerDeps = {
				runAudit: async () =>
					success({
						stdout: '',
						stderr: '',
					}),
			};

			const analyzer = createVulnerabilityAnalyzer(mockDeps);
			const context = createContext();

			const result = await analyzer.analyze(context);

			assert.strictEqual(result.success, true);
			if (result.success) {
				assert.strictEqual(result.data.length, 0);
			}
		});

		test('should handle missing workspacePath', async () => {
			const mockDeps: VulnerabilityAnalyzerDeps = {
				runAudit: async () =>
					success({
						stdout: JSON.stringify({ vulnerabilities: {} }),
						stderr: '',
					}),
			};

			const analyzer = createVulnerabilityAnalyzer(mockDeps);
			const context = createContext('');

			const result = await analyzer.analyze(context);

			assert.strictEqual(result.success, true);
			if (result.success) {
				assert.strictEqual(result.data.length, 0);
			}
		});

		test('should handle malformed audit structure', async () => {
			const mockDeps: VulnerabilityAnalyzerDeps = {
				runAudit: async () =>
					success({
						stdout: JSON.stringify({
							random: 'structure',
						}),
						stderr: '',
					}),
			};

			const analyzer = createVulnerabilityAnalyzer(mockDeps);
			const context = createContext();

			const result = await analyzer.analyze(context);

			assert.strictEqual(result.success, true);
			if (result.success) {
				assert.strictEqual(result.data.length, 0);
			}
		});
	});

	suite('No Vulnerabilities', () => {
		test('should handle clean audit with no vulnerabilities', async () => {
			const mockDeps: VulnerabilityAnalyzerDeps = {
				runAudit: async () =>
					success({
						stdout: JSON.stringify({
							vulnerabilities: {},
						}),
						stderr: '',
					}),
			};

			const analyzer = createVulnerabilityAnalyzer(mockDeps);
			const context = createContext();

			const result = await analyzer.analyze(context);

			assert.strictEqual(result.success, true);
			if (result.success) {
				assert.strictEqual(result.data.length, 0);
			}
		});
	});
});

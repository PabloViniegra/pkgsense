import { execFile } from 'node:child_process';
import { promisify } from 'node:util';
import { CONSTANTS } from '../shared/constants';
import { type Result, failure, success } from '../shared/result';
import { FINDING_TAGS, type Finding, type Severity } from '../types';
import type { Analyzer, AnalysisContext } from './types';

const execFileAsync = promisify(execFile);

// Vulnerability severity levels from npm audit
type VulnerabilitySeverity = 'low' | 'moderate' | 'high' | 'critical';

interface VulnerabilityEntry {
	readonly module_name?: string;
	readonly name?: string;
	readonly package_name?: string;
	readonly title?: string;
	readonly severity?: VulnerabilitySeverity;
	readonly metadata?: {
		readonly severity?: VulnerabilitySeverity;
	};
	readonly findings?: readonly {
		readonly package?: string;
	}[];
}

interface AuditJson {
	readonly vulnerabilities?: Readonly<Record<string, VulnerabilityEntry>>;
	readonly advisories?: Readonly<Record<string, VulnerabilityEntry>>;
}

/**
 * Audit command execution result.
 */
interface AuditResult {
	readonly stdout: string;
	readonly stderr: string;
}

/**
 * Dependencies for the vulnerability analyzer.
 * Following Dependency Inversion Principle - depend on abstractions.
 */
export interface VulnerabilityAnalyzerDeps {
	/**
	 * Function to execute npm audit command.
	 * Injected to enable testing with mock implementations.
	 */
	readonly runAudit: (cwd: string) => Promise<Result<AuditResult, string>>;
}

/**
 * Default npm audit executor.
 */
async function defaultRunAudit(
	cwd: string,
): Promise<Result<AuditResult, string>> {
	try {
		const { stdout, stderr } = await execFileAsync('npm', ['audit', '--json'], {
			cwd,
			maxBuffer: CONSTANTS.EXEC_MAX_BUFFER,
			timeout: CONSTANTS.EXEC_TIMEOUT_MS,
		});

		return success({ stdout, stderr });
	} catch (error) {
		if (error instanceof Error) {
			const execError = error as Error & { stdout?: string; stderr?: string };

			// npm audit returns exit code 1 when vulnerabilities are found
			// but still provides valid JSON output
			if (execError.stdout) {
				return success({
					stdout: execError.stdout,
					stderr: execError.stderr || '',
				});
			}

			if (execError.message.includes('ENOENT')) {
				return failure('npm command not found');
			}

			if (execError.message.includes('timeout')) {
				return failure('npm audit command timed out');
			}

			return failure(`Error running npm audit: ${execError.message}`);
		}

		return failure('Unknown error running npm audit');
	}
}

/**
 * Default dependencies using the real npm audit command.
 */
const DEFAULT_DEPS: VulnerabilityAnalyzerDeps = {
	runAudit: defaultRunAudit,
};

// Type guard for audit JSON structure
function isAuditJson(data: unknown): data is AuditJson {
	if (typeof data !== 'object' || data === null) {
		return false;
	}

	const obj = data as Record<string, unknown>;

	// Must have either vulnerabilities or advisories
	if (!('vulnerabilities' in obj) && !('advisories' in obj)) {
		return false;
	}

	return true;
}

// Convert vulnerability severity to finding severity with exhaustive checking
function mapSeverityToFindingSeverity(
	severity: VulnerabilitySeverity,
): Severity {
	switch (severity) {
		case 'critical':
		case 'high':
			return 'error';
		case 'moderate':
		case 'low':
			return 'warning';
		default: {
			// Exhaustive check - TypeScript will error if we miss a case
			const _exhaustive: never = severity;
			return _exhaustive;
		}
	}
}

/**
 * Parse npm audit JSON output into findings.
 * Pure function - no side effects.
 */
function parseAuditOutput(stdout: string): Finding[] {
	const json: unknown = JSON.parse(stdout);

	if (!isAuditJson(json)) {
		console.warn('Invalid npm audit JSON format');
		return [];
	}

	const advisories = json.vulnerabilities ?? json.advisories ?? {};
	const results: Finding[] = [];

	for (const key of Object.keys(advisories)) {
		const entry = advisories[key];
		if (!entry) continue;

		const moduleName =
			entry.module_name ??
			entry.name ??
			entry.package_name ??
			entry.findings?.[0]?.package;

		const title = entry.title ?? 'Vulnerability detected';
		const severity: VulnerabilitySeverity =
			entry.severity ?? entry.metadata?.severity ?? 'moderate';

		results.push({
			type: mapSeverityToFindingSeverity(severity),
			message: `${title} (severity: ${severity})`,
			dependency: moduleName,
			tags: [FINDING_TAGS.SECURITY],
		});
	}

	return results;
}

/**
 * Creates a vulnerability analyzer that checks for security vulnerabilities.
 *
 * Factory pattern with dependency injection enables:
 * - Testing with mock audit results
 * - Swapping audit tools (npm, pnpm, yarn) without changing analyzer logic
 * - Dependency inversion principle compliance
 */
export function createVulnerabilityAnalyzer(
	deps: VulnerabilityAnalyzerDeps = DEFAULT_DEPS,
): Analyzer {
	return {
		name: 'vulnerability',

		async analyze(context: AnalysisContext) {
			const { workspacePath } = context;

			if (!workspacePath) {
				return success([]);
			}

			const auditResult = await deps.runAudit(workspacePath);

			if (!auditResult.success) {
				console.error(auditResult.error);
				// Return empty findings on audit failure - don't fail the whole analysis
				return success([]);
			}

			const { stdout } = auditResult.data;

			if (!stdout) {
				return success([]);
			}

			try {
				const findings = parseAuditOutput(stdout);
				return success(findings);
			} catch (error) {
				const errorMessage =
					error instanceof Error ? error.message : 'Unknown error';
				console.error(`Error parsing npm audit output: ${errorMessage}`);
				return success([]);
			}
		},
	};
}

/**
 * @deprecated Use createVulnerabilityAnalyzer() factory instead.
 * Kept for backward compatibility during migration.
 */
export async function vulnerabilityAnalyzer(
	cwd: string,
): Promise<readonly Finding[]> {
	const analyzer = createVulnerabilityAnalyzer();
	const context: AnalysisContext = {
		packageJson: {},
		allDependencies: {},
		dependencyRanges: {},
		workspacePath: cwd,
	};

	const result = await analyzer.analyze(context);
	return result.success ? result.data : [];
}
